<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIT Delhi </title>
    <style>
        :root {
            /* Color Palette */
            --primary-color: #1a5f7a;       /* Deep Teal */
            --secondary-color: #2c8eb3;     /* Bright Blue */
            --accent-color: #f39c12;        /* Warm Orange */
            --text-primary: #2c3e50;        /* Dark Slate */
            --text-secondary: #34495e;      /* Soft Charcoal */
            --background-light: #ecf0f1;    /* Light Gray */
            --background-white: #ffffff;    /* Pure White */
            --shadow-subtle: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.15);
            --icon-color: #ffffff;

            /* Typography */
            --font-primary: 'Inter', 'Segoe UI', Roboto, system-ui, -apple-system, sans-serif;
        }

        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--background-light);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .title {
            color: var(--primary);
            margin-bottom: 20px;
        }

        .visualizer-container {
            background: black;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
        }

        #spectrogramCanvas {
            width: 100%;
            height: 300px;
            border-radius: 4px;
        }


        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 5%;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            box-shadow: 0 4px 6px var(--shadow-subtle);
            position: relative;
        }

        .logo img {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Mobile Menu Hamburger Icon */
        .menu-toggle {
            display: none;
            flex-direction: column;
            cursor: pointer;
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
        }


        .menu-toggle span {
            width: 25px;
            height: 3px;
            background-color: var(--icon-color);
            margin: 3px 0;
            transition: 0.4s;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 20px;
        }

        nav ul li a {
            color: var(--background-white);
            text-decoration: none;
            padding: 10px 15px;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        nav ul li a.active {
            background-color: rgba(255,255,255,0.2);
        }

        main {
            flex: 1;
            max-width: 1200px;
            width: 95%;
            margin: 2rem auto;
            padding: 2rem;
            background-color: var(--background-white);
            border-radius: 15px;
            box-shadow: 0 10px 25px var(--shadow-medium);
        }

        h1 {
            text-align: center;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }
        .partner-logos {
            display: flex;
            justify-content: center;
            gap: 20px; /* Space between logos */
            margin-top: 20px; /* Space above the logo row */
            margin-bottom: 50px; /* Space below the logo row */
        }

        .partner-logo {
            height: 80px; /* Control the size of the logos */
            width: auto; /* Maintain aspect ratio */
            transition: transform 0.3s ease; /* Smooth transform on hover */
        }

        .partner-logo:hover {
            transform: scale(1.1); /* Slightly enlarge logos on hover */
        }


        .cta-buttons {
            justify-content: center; 
            margin-top: 1rem;
            display: flex;
            gap: 15px;
        }

        .btn {
            display: inline-block;
            padding: 12px 25px;
            background-color: var(--secondary-color);
            color: var(--background-white);
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background-color: var(--primary-color);
            transform: translateY(-3px);
        }

        #audioList {
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .date-group {
            width: 100%;
            margin-bottom: 2rem; /* Add space between date groups */
            padding: 0;
        }

        .date-header {
            width: 100%;
            margin: 1rem 0;
            color: var(--text-primary);
            font-size: 1.5rem;
        }

        .project-details ul, .audio-list, .waveform-visualizations .visualizations, .project-applications .application-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 1rem;
            width: 100% ;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }


        .project-details li, .audio-item, .visualization-item, .application-item {
            background-color: var(--background-light);
            padding: 1rem;  
            border-radius: 10px;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 6px var(--shadow-subtle);
        }
        
        .audio-item p {
            margin: 0;
            font-weight: bold;
            color: var(--text-primary);
        }

        .audio-item audio {
            width: 100%;
            margin: 10px 0 ;
        }

        .recording-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 5px;
        }

        .time-info {
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        .recording-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-top: 1rem;
        }

        .recording-duration {
            display: block;
            color: #666;
            font-size: 0.9em;
            margin-top: 4px;
        }


        .record-btn {
            background-color: #f39c12;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .record-btn:hover {
            background-color: #d35400;
        }

        .record-btn.recording {
            background-color: #e74c3c;
            animation: pulse 1s infinite alternate;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.3s;
        }

        .download-btn {
            background-color: var(--secondary-color); /* Uses the blue theme color */
            color: var(--background-white);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }


        .download-btn:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
        }


        button:hover {
            background: var(--secondary);
        }

        button.recording {
            background: #e74c3c;
            animation: pulse 1s infinite;
        }

        .spectrogram-container {
            width: 100%;
            background: black;
            border-radius: 8px;
            padding: 10px;
            margin: 20px 0;
        }

        .classifier-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .classifier-button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background-color: var(--secondary-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .classifier-button:hover {
            background-color: var(--primary-color);
        }

        .classification-result {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--background-light);
            border-radius: 8px;
        }

        .result-label {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .result-value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--primary-color);
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }

        .recording-time {
            font-weight: bold;
            color: #34495e;
        }

        /* Spectrogram Styles */
        .spectrogram-controls {
            margin: 15px 0;
            padding: 15px;
            background-color: var(--background-light);
            border-radius: 8px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .classification-result {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }


        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 500;
            color: var(--text-primary);
        }

        .control-group select,
        .control-group input {
            padding: 5px;
            border: 1px solid var(--primary-color);
            border-radius: 4px;
        }

        


        #spectrogramCanvas {
            width: 100%;
            height: auto;
            background-color: black;
            border-radius: 4px;
        }

        .frequency-axis {
            height: 30px;
            margin-top: 5px;
            position: relative;
            border-left: 1px solid var(--text-secondary);
        }

        .frequency-marker {
            position: absolute;
            transform: translateX(-50%);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .time-axis {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .visualization-controls {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.viz-tab-btn {
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 8px;
    background-color: var(--background-light);
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
}

.viz-tab-btn.active {
    background-color: var(--secondary-color);
    color: var(--background-white);
}

.recording-selector {
    margin-bottom: 1rem;
}

.recording-selector select {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    background-color: var(--background-white);
    color: var(--text-primary);
}

        footer {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--background-white);
            text-align: center;
            padding: 1rem;
            margin-top: auto;
        }

        .highlight-box {
            position: absolute;
            border: 2px solid var(--accent);
            background: rgba(243, 156, 18, 0.1);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        /* Responsive Design */

        @media (max-width: 992px) {
            .audio-list {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }

        @media (max-width: 768px) {
            header {
                flex-direction: column;
                text-align: center;
            }

            .menu-toggle {
                display: flex;
            }

            nav {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                width: 100%;
                background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
                flex-direction: column;
                align-items: center;
                padding: 1rem 0;
            }

            nav.active {
                display: flex;
            }

            nav ul {
                flex-direction: column;
                width: 100%;
                align-items: center;
            }

            nav ul li {
                width: 100%;
                text-align: center;
            }

            nav ul li a {
                display: block;
                padding: 15px;
                width: 100%;
            }

            .date-group .audio-list {
                grid-template-columns: 1fr; /* Stack items vertically on mobile */
            }

        }

        @media (max-width: 480px) {
            .project-details ul, 
            .audio-list, 
            .waveform-visualizations .visualizations, 
            .project-applications .application-grid {
                grid-template-columns: 1fr;
            }

            main {
                padding: 1rem;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <img src="kit_logo.png" alt="IIT Delhi Logo" width="150" height="150">
        </div>
        
        <div class="menu-toggle">
            <span></span>
            <span></span>
            <span></span>
        </div>

        <nav>
            <ul>
                <li><a href="#home" class="nav-link active" data-section="home">Home</a></li>
                <li><a href="#data" class="nav-link" data-section="data">Record</a></li>
                <li><a href="#data-visualization" class="nav-link" data-section="data-visualization">Data Visualization</a></li>
                <li><a href="#about" class="nav-link" data-section="about">About</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section id="home">
            <h1>Welcome to the homepage of Kit-Tunog-Net</h1>
            <p style="text-align: center;">Real-Time Insect Sound Classification in Stored Grain Using Convolutional Neural Networks.</p>
            <!-- <p>Real-Time Insect Sound Classification in Stored Grain Using Convolutional Neural Networks.</p> -->
            <!-- <p>Currently, this project is being built with the collaboration.</p> -->
        
            <!-- Partner Logos -->
            <div class="partner-logos">
                <img src="uni_kassel_logo.png" alt="Uni Kassel Logo" class="partner-logo">
                <img src="irri_logo.png" alt="IRRI Logo" class="partner-logo">
                <img src="iitd_logo.png" alt="IIT Delhi Logo" class="partner-logo">
            </div>
        
            <div class="cta-buttons">
                <a href="#about" class="btn btn-primary" onclick="navigateToSection('about')">Learn More</a>
                <a href="#data-visualization" class="btn btn-secondary" onclick="navigateToSection('data-visualization')">View Visualizations</a>
            </div>
        </section>

        <section id="about" style="display:none;">
            <h1>About the Project</h1>
            <p>Insect infestations pose considerable risks to agricultural outputs, affecting both the quantity and quality of crops, which in turn threatens global food security. Conventional control methods often rely on expert human analysis, making them unsuitable for large-scale application due to inefficiencies and scalability issues. In this study, we propose a deep learning-based solution for the real-time acoustic monitoring of insect pests in grain storage, addressing several critical challenges in the domain. Firstly, the lack of a comprehensive dataset for three key pest species was overcome by curating a large-scale dataset comprising ___ samples. Secondly, to address the limitations of traditional feature-based machine learning techniques, which are not well-suited for large-scale deployment, we developed a Spectrogram-based Convolutional Neural Network (CNN) that achieves an accuracy of 84.51%. Lastly, we designed a framework for edge-based deployment, facilitating real-time operational capability. Our approach provides a cost-effective, portable solution for postharvest pest management, enabling prompt and effective responses to pest infestations and enhancing the protection of stored grains.
            </p>
            
            <div class="project-details">
                <h2>Project Stages</h2>
                <ul>
                    <li>
                        <strong>Data Collection</strong>
                        <p>Gathering comprehensive audio samples across various sound categories.</p>
                    </li>
                    <li>
                        <strong>Preprocessing</strong>
                        <p>Cleaning and preparing data for machine learning model training.</p>
                    </li>
                    <li>
                        <strong>Model Training</strong>
                        <p>Utilizing state-of-the-art algorithms to develop an accurate sound recognition system.</p>
                    </li>
                    <li>
                        <strong>Evaluation</strong>
                        <p>Rigorous testing to ensure high performance and reliability.</p>
                    </li>
                </ul>
            </div>
        </section>

        <section id="data" style="display:none;">
            <h1>Record Sound Data</h1>
            <div class="recording-controls">
                <button id="recordButton" class="record-btn">
                    🔴 Record
                </button>
                <span id="recordingTime" class="recording-time">00:00</span>
            </div>
            
            <div class="audio-list" id="audioList">
                <!-- Audio recordings will be added here dynamically -->
            </div>
        </section>

        <section id="data-visualization" style="display:none;">
            <h1>Sound Analysis</h1>
            
            <div class="visualization-controls">
                <button class="viz-tab-btn active" data-tab="online">Online Analysis</button>
                <button class="viz-tab-btn" data-tab="offline">Offline Analysis</button>
            </div>
        
            <div id="online-visualization" class="visualization-content">
                <div class="visualization-item">
                    <h2>Live Spectrogram with Classification</h2>
                    <div class="classifier-controls">
                        <button id="startClassifier" class="classifier-button">Start Classification</button>
                        <button id="stopClassifier" class="classifier-button" style="display:none;">Stop Classification</button>
                    </div>
                    <div class="spectrogram-container">
                        <canvas id="spectrogramCanvas"></canvas>
                    </div>
                    <div class="classification-result">
                        <div class="result-label">Current Sound Classification:</div>
                        <div id="predictionValue" class="result-value">-</div>
                    </div>
                </div>
            </div>
        
            <div id="offline-visualization" class="visualization-content" style="display:none;">
                <div class="visualization-item">
                    <h2>Recorded Audio Analysis</h2>
                    <div class="recording-selector">
                        <select id="recordingSelect">
                            <option value="">Select a recording</option>
                        </select>
                    </div>
                    <div class="spectrogram-container">
                        <canvas id="offlineSpectrogramCanvas"></canvas>
                    </div>
                    <div class="classification-result">
                        <div class="result-label">Sound Classification:</div>
                        <div id="offlinePredictionValue" class="result-value">-</div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>© 2024 IIT Delhi. All Rights Reserved. Don't even try to copy us, we're all in.</p>
    </footer>

    <script>

        function navigateToSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('section').forEach(section => {
                section.style.display = 'none';
            });
            
            // Show the selected section
            document.getElementById(sectionId).style.display = 'block';
            
            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('data-section') === sectionId) {
                    link.classList.add('active');
                }
            });

            // Smooth scroll to the section
            document.getElementById(sectionId).scrollIntoView({ behavior: 'smooth' });
        }

        // Add click event listeners to all navigation links
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const sectionId = link.getAttribute('data-section');
                navigateToSection(sectionId);
            });
        });

        // Mobile menu toggle
        const menuToggle = document.querySelector('.menu-toggle');
        const nav = document.querySelector('nav');
        
        menuToggle.addEventListener('click', () => {
            nav.classList.toggle('active');
        });

        // Close mobile menu when a link is clicked
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', () => {
                nav.classList.remove('active');
            });
        });
        
        // Audio Recording and Visualization Variables
        // Audio Recording and Visualization Variables
        // Audio Recording and Visualization Variables
        let globalStream = null;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        // let startTime;
        let recordingStartTime;
        let timerInterval;

        // Format time as MM:SS
        function formatTime(duration) {
            if (!duration) return '00:00';
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        function updateTimer() {
            if (recordingStartTime) {
                const duration = (Date.now() - recordingStartTime) / 1000;
                document.getElementById('recordingTime').textContent = formatTime(duration);
            }
        }


        // Get the next recording number
        function calculateDuration(audioBlob) {
            return new Promise(resolve => {
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.addEventListener('loadedmetadata', () => {
                    const duration = audio.duration;
                    URL.revokeObjectURL(audioUrl);
                    resolve(duration);
                });
            });
        }             


        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

            // Format date and time for display
        function formatDateTime(timestamp) {
            const date = new Date(timestamp);
            return {
                date: date.toLocaleDateString('en-US', { 
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric'
                }),
                time: date.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                })
            };
        }

        function getNextRecordingNumber() {
            const recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
            const numbers = recordings.map(rec => {
                const match = rec.name.match(/Recording (\d+)/);
                return match ? parseInt(match[1]) : 0;
            });
            return numbers.length > 0 ? Math.max(...numbers) + 1 : 1;
        }

        // Save recording to localStorage
        async function saveRecording(blob) {
            try {
                const duration = await calculateDuration(blob);
                const reader = new FileReader();
                
                reader.onloadend = function() {
                    const recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
                    recordings.push({
                        id: Date.now(),
                        name: `Recording ${getNextRecordingNumber()}`,
                        data: reader.result,
                        timestamp: Date.now(),
                        duration: duration // Store the actual duration
                    });
                    localStorage.setItem('recordings', JSON.stringify(recordings));
                    displayRecordings();
                };
                
                reader.readAsDataURL(blob);
            } catch (error) {
                console.error('Error saving recording:', error);
            }
        }

        // Group recordings by date
        function groupRecordingsByDate(recordings) {
            const groups = {};
            recordings.forEach(recording => {
                const { date } = formatDateTime(recording.timestamp);
                if (!groups[date]) {
                    groups[date] = [];
                }
                groups[date].push(recording);
            });
            return groups;
        }

        // Display all recordings from localStorage
        function displayRecordings() {
            const audioList = document.getElementById('audioList');
            audioList.innerHTML = '';
            
            const recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
            const fifteenDaysAgo = Date.now() - (15 * 24 * 60 * 60 * 1000);
            const currentRecordings = recordings.filter(recording => recording.timestamp > fifteenDaysAgo);
            
            const groupedRecordings = groupRecordingsByDate(currentRecordings);
            const sortedDates = Object.keys(groupedRecordings).sort((a, b) => new Date(b) - new Date(a));
            
            sortedDates.forEach(date => {
                const dateGroup = document.createElement('div');
                dateGroup.className = 'date-group';

                const dateHeader = document.createElement('h2');
                dateHeader.className = 'date-header';
                dateHeader.textContent = date;

                const recordingsGrid = document.createElement('div');
                recordingsGrid.className = 'audio-list';

                const sortedRecordings = groupedRecordings[date].sort((a, b) => b.timestamp - a.timestamp);
                
                sortedRecordings.forEach(recording => {
                    const audioItem = document.createElement('div');
                    audioItem.className = 'audio-item';

                    const recordingInfo = document.createElement('div');
                    recordingInfo.className = 'recording-info';

                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'recording-name';
                    nameDiv.textContent = recording.name;

                    const timeInfo = document.createElement('div');
                    timeInfo.className = 'time-info';
                    
                    const timeDiv = document.createElement('div');
                    timeDiv.textContent = formatDateTime(recording.timestamp).time;
                    
                    const durationDiv = document.createElement('div');
                    durationDiv.className = 'recording-duration';
                    durationDiv.textContent = formatTime(recording.duration); // Use the stored duration

                    timeInfo.appendChild(timeDiv);
                    timeInfo.appendChild(durationDiv);
                    recordingInfo.appendChild(nameDiv);
                    recordingInfo.appendChild(timeInfo);

                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = recording.data;

                    const downloadBtn = document.createElement('button');
                    downloadBtn.className = 'download-btn';
                    downloadBtn.textContent = 'Download Recording';
                    downloadBtn.onclick = () => {
                        const link = document.createElement('a');
                        link.href = recording.data;
                        link.download = `${recording.name}.wav`;
                        link.click();
                    };

                    audioItem.appendChild(recordingInfo);
                    audioItem.appendChild(audio);
                    audioItem.appendChild(downloadBtn);
                    recordingsGrid.appendChild(audioItem);
                });

                dateGroup.appendChild(dateHeader);
                dateGroup.appendChild(recordingsGrid);
                audioList.appendChild(dateGroup);
            });
        }


        async function initialize() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                globalStream = stream;
                console.log('Microphone permission granted and stream initialized');
                // Display existing recordings on initialization
                displayRecordings();
                return true;
            } catch (err) {
                console.error('Error during initialization:', err);
                alert('Error accessing microphone. Please ensure microphone permissions are granted.');
                return false;
            }
        }

        async function toggleRecording() {
            const recordButton = document.getElementById('recordButton');
            const timeDisplay = document.getElementById('recordingTime');

            if (!isRecording) {
                if (!globalStream) {
                    const initialized = await initialize();
                    if (!initialized) return;
                }

                mediaRecorder = new MediaRecorder(globalStream);
                audioChunks = [];
                recordingStartTime = Date.now();

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    await saveRecording(audioBlob);
                };

                mediaRecorder.start();
                isRecording = true;
                recordButton.textContent = '⏹️ Stop Recording';
                recordButton.classList.add('recording');
                timerInterval = setInterval(updateTimer, 100);
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordButton.textContent = '🔴 Record';
                recordButton.classList.remove('recording');
                clearInterval(timerInterval);
                timeDisplay.textContent = '00:00';
                recordingStartTime = null;
            }
        }

        document.addEventListener('DOMContentLoaded', initialize);
        document.getElementById('recordButton').addEventListener('click', toggleRecording);

        // Check for expired recordings every hour
        setInterval(() => {
            displayRecordings();
        }, 60 * 60 * 1000);

        class AudioClassifier {
        constructor() {
            // Initialize canvas and context
            this.canvas = document.getElementById('spectrogramCanvas');
            this.ctx = this.canvas.getContext('2d');
            
            // Initialize dimensions
            this.canvas.width = this.canvas.parentElement.offsetWidth;
            this.canvas.height = 300;
            
            // Get UI elements
            this.startButton = document.getElementById('startClassifier');
            this.stopButton = document.getElementById('stopClassifier');
            this.predictionDisplay = document.getElementById('predictionValue');
            
            // Initialize audio processing variables
            this.audioContext = null;
            this.analyser = null;
            this.dataArray = null;
            this.bufferLength = null;
            this.stream = null;
            this.isRecording = false;
            this.animationFrame = null;
            
            // Set up event listeners
            this.setupEventListeners();
        }


    setupEventListeners() {
        this.startButton.addEventListener('click', () => {
            this.startRecording();
            this.startButton.style.display = 'none';
            this.stopButton.style.display = 'block'; // Make sure the stop button shows
        });

        this.stopButton.addEventListener('click', () => {
            this.stopRecording();
            this.stopButton.style.display = 'none';
            this.startButton.style.display = 'block';
        });

        window.addEventListener('resize', () => {
            this.initializeCanvas();
        });
    }

            initializeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.offsetWidth;
                this.canvas.height = 300;
                
                // Set initial black background
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            setupEventListeners() {
                this.startButton.addEventListener('click', () => {
                    this.startRecording();
                    this.startButton.style.display = 'none';
                    this.stopButton.style.display = 'block';
                });

                this.stopButton.addEventListener('click', () => {
                    this.stopRecording();
                    this.stopButton.style.display = 'none';
                    this.startButton.style.display = 'block';
                });

                window.addEventListener('resize', () => {
                    this.initializeCanvas();
                });
            }

            async startRecording() {
                try {
                    if (!globalStream) {
                        console.error('No audio stream available');
                        alert('Please reload the page to grant microphone access.');
                        return;
                    }
                    
                    this.stream = globalStream;
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    
                    const source = this.audioContext.createMediaStreamSource(this.stream);
                    source.connect(this.analyser);
                    
                    // Configure analyser for better frequency resolution
                    this.analyser.fftSize = 2048;
                    this.analyser.smoothingTimeConstant = 0.2;
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(this.bufferLength);
                    
                    this.isRecording = true;
                    this.drawSpectrogram();
                    this.startClassification();
                } catch (error) {
                    console.error('Error starting audio processing:', error);
                    alert('An error occurred while processing audio.');
                }
            }

            stopRecording() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                }
                
                this.isRecording = false;
                this.predictionDisplay.textContent = '-';
                this.spectrogramData = [];
                
                clearInterval(this.classificationInterval);
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                
                // Clear canvas
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawSpectrogram() {
    if (!this.isRecording) return;
    
    // Get frequency data
    this.analyser.getByteFrequencyData(this.dataArray);
    
    // Shift existing spectrogram left
    const imageData = this.ctx.getImageData(1, 0, this.canvas.width - 1, this.canvas.height);
    this.ctx.putImageData(imageData, 0, 0);
    
    // Calculate dimensions for visualization
    const height = this.canvas.height;
    const binCount = this.analyser.frequencyBinCount;
    const binHeight = height / binCount;
    
    // Draw new frequency data on the right edge
    for (let i = 0; i < binCount; i++) {
        const value = this.dataArray[i];
        
        // Calculate color based on frequency intensity
        const intensity = value / 255;
        
        // Create a gradient from blue to white based on intensity
        const r = Math.floor(intensity * 255);
        const g = Math.floor(intensity * 255);
        const b = 255;
        
        this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        
        // Draw the frequency bin
        const y = height - (i * binHeight) - binHeight;
        this.ctx.fillRect(
            this.canvas.width - 1,  // Draw on the rightmost edge
            y,                      // Y position based on frequency
            1,                      // Width of 1 pixel
            Math.ceil(binHeight)    // Height for this frequency bin
        );
    }
    
    // Add frequency scale on the right
    this.drawFrequencyScale();
    
    // Continue animation
    this.animationFrame = requestAnimationFrame(() => this.drawSpectrogram());
}

drawFrequencyScale() {
    const scaleWidth = 40;
    const frequencies = [0, 2000, 4000, 8000, 16000];
    const nyquist = this.audioContext.sampleRate / 2;
    
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    this.ctx.fillRect(this.canvas.width - scaleWidth, 0, scaleWidth, this.canvas.height);
    
    this.ctx.fillStyle = 'white';
    this.ctx.font = '10px Arial';
    this.ctx.textAlign = 'right';
    
    frequencies.forEach(freq => {
        const y = this.canvas.height - (freq / nyquist) * this.canvas.height;
        this.ctx.fillText(`${freq / 1000}kHz`, this.canvas.width - 2, y);
    });
}
            initializeCanvas() {
                const container = this.canvas.parentElement;
                const containerWidth = container.offsetWidth;
                const containerHeight = 300; // Fixed height
                
                // Set canvas dimensions with device pixel ratio for sharp rendering
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = containerWidth * dpr;
                this.canvas.height = containerHeight * dpr;
                
                // Scale canvas CSS dimensions
                this.canvas.style.width = `${containerWidth}px`;
                this.canvas.style.height = `${containerHeight}px`;
                
                // Scale context to match device pixel ratio
                this.ctx.scale(dpr, dpr);
                
                // Set initial black background
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            classifySound() {
                this.analyser.getByteFrequencyData(this.dataArray);
                
                // Define frequency ranges for voice (85-255 Hz), music (20-20000 Hz), and noise
                const frequencyRanges = {
                    voice: { start: 85, end: 255 },
                    music: { start: 20, end: 20000 }
                };
                
                // Calculate energy in each frequency range
                const nyquist = this.audioContext.sampleRate / 2;
                const getBinFromFreq = freq => Math.floor((freq / nyquist) * this.bufferLength);
                
                // Calculate energy for specific frequency ranges
                const getEnergy = (startFreq, endFreq) => {
                    const startBin = getBinFromFreq(startFreq);
                    const endBin = getBinFromFreq(Math.min(endFreq, nyquist));
                    const sum = this.dataArray.slice(startBin, endBin + 1)
                        .reduce((acc, val) => acc + val, 0);
                    return sum / (endBin - startBin + 1);
                };
                
                // Get energy levels for each range
                const voiceEnergy = getEnergy(frequencyRanges.voice.start, frequencyRanges.voice.end);
                const musicEnergy = getEnergy(frequencyRanges.music.start, frequencyRanges.music.end);
                
                // Get overall signal energy
                const totalEnergy = getEnergy(0, nyquist);
                
                // Classification thresholds
                const VOICE_THRESHOLD = 40;
                const MUSIC_THRESHOLD = 35;
                const NOISE_THRESHOLD = 20;

                // Pattern detection for voice (looking for speech patterns)
                const hasVoicePattern = this.detectVoicePattern();
                
                // Classification logic
                if (totalEnergy < NOISE_THRESHOLD) {
                    return 'Noise';
                } else if (voiceEnergy > VOICE_THRESHOLD && hasVoicePattern) {
                    return 'Human Voice';
                } else if (musicEnergy > MUSIC_THRESHOLD && this.detectMusicPattern()) {
                    return 'Music';
                } else {
                    return 'Noise';
                }
            }

            detectVoicePattern() {
                // Simple voice pattern detection based on frequency distribution
                const voiceRange = this.dataArray.slice(
                    Math.floor(this.bufferLength * 0.1), 
                    Math.floor(this.bufferLength * 0.3)
                );
                
                // Check for typical voice frequency patterns
                let peaks = 0;
                for (let i = 1; i < voiceRange.length - 1; i++) {
                    if (voiceRange[i] > voiceRange[i-1] && voiceRange[i] > voiceRange[i+1]) {
                        peaks++;
                    }
                }
                
                return peaks >= 3; // Voice typically has multiple harmonic peaks
            }

            detectMusicPattern() {
                // Simple music pattern detection
                let harmonics = 0;
                const threshold = 50;
                
                // Check for harmonic content (typical in music)
                for (let i = 0; i < this.bufferLength / 4; i++) {
                    if (this.dataArray[i] > threshold) {
                        harmonics++;
                    }
                }
                
                return harmonics >= 5; // Music typically has more harmonics
            }

            startClassification() {
                // Classify sound every 300ms for more responsive updates
                this.classificationInterval = setInterval(() => {
                    if (this.isRecording) {
                        const prediction = this.classifySound();
                        this.predictionDisplay.textContent = prediction;
                    }
                }, 300);
            }
        }

        // Initialize the classifier when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const classifier = new AudioClassifier();
        });
       
        
    </script>

<script>
    // Add this to your existing script
    document.addEventListener('DOMContentLoaded', () => {
        const vizTabs = document.querySelectorAll('.viz-tab-btn');
        const contents = document.querySelectorAll('.visualization-content');
        const recordingSelect = document.getElementById('recordingSelect');
    
        // Tab switching logic
        vizTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                vizTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                contents.forEach(content => {
                    content.style.display = 'none';
                });
                
                const targetId = `${tab.dataset.tab}-visualization`;
                document.getElementById(targetId).style.display = 'block';
            });
        });
    
        // Populate recordings dropdown
        function updateRecordingsList() {
            const recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
            recordingSelect.innerHTML = '<option value="">Select a recording</option>';
            
            recordings.forEach(recording => {
                const option = document.createElement('option');
                option.value = recording.id;
                option.textContent = `${recording.name} - ${formatDateTime(recording.timestamp).date}`;
                recordingSelect.appendChild(option);
            });
        }
    
        // Handle recording selection
        // Modified recording selection handler
        recordingSelect.addEventListener('change', async function() {
            const recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
            const selectedRecording = recordings.find(r => r.id === parseInt(this.value));
            
            if (selectedRecording) {
                const canvas = document.getElementById('offlineSpectrogramCanvas');
                const ctx = canvas.getContext('2d');
                const predictionDisplay = document.getElementById('offlinePredictionValue');

                // Create audio context and analyser
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                // Create audio element and connect to analyser
                const audio = new Audio(selectedRecording.data);
                const source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);

                // Set up canvas
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = 300;
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                let xPos = 0;
                
                // Classification helper functions
                function detectVoicePattern(dataArray, bufferLength) {
                    const voiceRange = dataArray.slice(
                        Math.floor(bufferLength * 0.1),
                        Math.floor(bufferLength * 0.3)
                    );
                    
                    let peaks = 0;
                    for (let i = 1; i < voiceRange.length - 1; i++) {
                        if (voiceRange[i] > voiceRange[i-1] && voiceRange[i] > voiceRange[i+1]) {
                            peaks++;
                        }
                    }
                    
                    return peaks >= 3;
                }

                function detectMusicPattern(dataArray, bufferLength) {
                    let harmonics = 0;
                    const threshold = 50;
                    
                    for (let i = 0; i < bufferLength / 4; i++) {
                        if (dataArray[i] > threshold) {
                            harmonics++;
                        }
                    }
                    
                    return harmonics >= 5;
                }

                function classifySound(dataArray, bufferLength, audioContext) {
                    const nyquist = audioContext.sampleRate / 2;
                    const getBinFromFreq = freq => Math.floor((freq / nyquist) * bufferLength);
                    
                    const getEnergy = (startFreq, endFreq) => {
                        const startBin = getBinFromFreq(startFreq);
                        const endBin = getBinFromFreq(Math.min(endFreq, nyquist));
                        const sum = Array.from(dataArray.slice(startBin, endBin + 1))
                            .reduce((acc, val) => acc + val, 0);
                        return sum / (endBin - startBin + 1);
                    };

                    const voiceEnergy = getEnergy(85, 255);
                    const musicEnergy = getEnergy(20, 20000);
                    const totalEnergy = getEnergy(0, nyquist);

                    const VOICE_THRESHOLD = 40;
                    const MUSIC_THRESHOLD = 35;
                    const NOISE_THRESHOLD = 20;

                    if (totalEnergy < NOISE_THRESHOLD) {
                        return 'Noise';
                    } else if (voiceEnergy > VOICE_THRESHOLD && detectVoicePattern(dataArray, bufferLength)) {
                        return 'Human Voice';
                    } else if (musicEnergy > MUSIC_THRESHOLD && detectMusicPattern(dataArray, bufferLength)) {
                        return 'Music';
                    } else {
                        return 'Noise';
                    }
                }

                function draw() {
                    if (xPos >= canvas.width) {
                        xPos = 0;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    analyser.getByteFrequencyData(dataArray);

                    // Draw spectrogram column
                    for (let i = 0; i < bufferLength; i++) {
                        const value = dataArray[i];
                        const y = canvas.height - (i * canvas.height / bufferLength);
                        
                        const intensity = value / 255;
                        ctx.fillStyle = `rgb(${intensity * 255}, ${intensity * 255}, 255)`;
                        ctx.fillRect(xPos, y, 1, canvas.height / bufferLength);
                    }

                    xPos++;

                    // Update classification
                    const prediction = classifySound(dataArray, bufferLength, audioContext);
                    predictionDisplay.textContent = prediction;

                    requestAnimationFrame(draw);
                }

                audio.play();
                draw();
            }
        });
            
                // Update recordings list when visualizer is shown
                document.querySelector('[data-tab="offline"]').addEventListener('click', updateRecordingsList);
            });
    </script>
</body>
</html>         